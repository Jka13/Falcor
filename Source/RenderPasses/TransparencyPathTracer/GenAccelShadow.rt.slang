#include "Scene/SceneDefines.slangh"
#include "Utils/Math/MathConstants.slangh"

import Scene.Raytracing;
import Scene.Intersection;
import Utils.Math.MathHelpers;
import Utils.Geometry.GeometryHelpers;

#ifndef MAX_ELEMENTS
#define MAX_ELEMENTS 256
#endif

#ifndef NUM_LIGHTS
#define NUM_LIGHTS 1
#endif

//Maximum index 
#ifndef MAX_IDX
#define MAX_IDX 1
#endif

#define ACCEL_MODE_SHADOW3D 0
#define ACCEL_MODE_NORMALOFFSET 1

#ifndef ACCEL_MODE
#define ACCEL_MODE ACCEL_MODE_SHADOW3D
#endif

/** Payload for shadow ray.
*/
struct RayData
{
    float dist;
    float depth;
    float currentTransmittance;
    float depthRange;


    __init() {
        this.dist = -1.0;
        this.depth = 1.0;
        this.currentTransmittance = 1.0;
        this.depthRange = 0.0;
    }
};

cbuffer CB
{
    uint gFrameCount; // Current frame count
    float3 gLightPos; // Current Light Position
    float gNear;
    float gFar;
    uint2 _pad;
    float4x4 gViewProj;    // View Projection for current light
    float4x4 gInvViewProj; // Inverse view projection
    float4x4 gInvProj;
    float4x4 gView;
}

RWStructuredBuffer<AABB> gAABB;
RWBuffer<uint> gCounter;
RWStructuredBuffer<float4> gData;

static const float kDepthBias = AVSM_DEPTH_BIAS;
static const float kNormalBias = AVSM_NORMAL_DEPTH_BIAS;
static const float kMinOpacity = 1e-7;
static const float kPixelOffset = 0.5;

static const float2 kMSAAPattern[16] = { float2(0.0625, 0.0625), float2(-0.0625, -0.1875), float2(-0.1875, 0.125), float2(0.25, -0.0625),
                                         float2(-0.3125, -0.125),  float2(0.125, 0.3125), float2(0.3125, 0.1875), float2(0.1875, -0.3125),
                                         float2(-0.125, 0.375), float2(0.0, -0.4375),   float2(-0.25, 0.375),     float2(-0.375, 0.25),
                                         float2(-0.5, 0.0),      float2(0.4375, -0.25),    float2(0.375, 0.4375), float2(-0.4375, -0.5)
                                       };

/** Setup ShadingData based on loaded vertex/material attributes for a hit point.
    \param[in] hit Hit information.
    \param[in] rayOrigin Ray origin.
    \param[in] rayDir Normalized ray direction.
    \param[in] lod Method for computing texture level-of-detail.
    \return ShadingData struct.
*/
ShadingData loadShadingData(const HitInfo hit, const float3 rayDir, const ITextureSampler lod)
{
    const TriangleHit triangleHit = hit.getTriangleHit();
    VertexData v = gScene.getVertexData(triangleHit);
    uint materialID = gScene.getMaterialID(triangleHit.instanceID);

    ShadingData sd = gScene.materials.prepareShadingData(v, materialID, -rayDir, lod);

    return sd;
}

//Shaders
[shader("miss")]
void miss(inout RayData rayData)
{
    rayData.dist = -1.0;
}

//
// Shader entry points for TriangleMesh hit groups.
//

[shader("anyhit")]
void anyHit(inout RayData rayData, BuiltInTriangleIntersectionAttributes attribs)
{
    // Alpha test for non-opaque geometry.
    GeometryInstanceID instanceID = getGeometryInstanceID();
    VertexData v = getVertexData(instanceID, PrimitiveIndex(), attribs);
    const uint materialID = gScene.getMaterialID(instanceID);
    if (gScene.materials.alphaTest(v, materialID, 0.f, kMinOpacity)) IgnoreHit();
}


[shader("closesthit")]
void closestHit(inout RayData rayData, BuiltInTriangleIntersectionAttributes attribs)
{
    TriangleHit triangleHit;
    triangleHit.instanceID = getGeometryInstanceID();
    triangleHit.primitiveIndex = PrimitiveIndex();
    triangleHit.barycentrics = attribs.barycentrics;

    VertexData v = gScene.getVertexData(triangleHit);
    uint materialID = gScene.getMaterialID(triangleHit.instanceID);
    let lod = ExplicitLodTextureSampler(0.f);
    ShadingData sd = gScene.materials.prepareShadingData(v, materialID, -WorldRayDirection(), lod);

    rayData.currentTransmittance = rayData.currentTransmittance * (1.0 - sd.opacity);
    float4 posH = mul(gViewProj, float4(sd.posW, 1.f));
    //rayData.depth = posH.w; // Linear depth
    float3 posView = mul(gView, float4(sd.posW, 1.f)).xyz;
    rayData.depth = -1.0 * posView.z; //same as above
    //  float normalBias = (1.0 - abs(dot(WorldRayDirection(), sd.faceN))) * kNormalBias;
    //  rayData.depth = rayData.depth + (kDepthBias * gFar) + (normalBias * gFar);

    //Get the for corners of the pixel to approximate the size of the 3D pixel
    float2 pixel = float2(DispatchRaysIndex().xy) + 0.5;
    const uint2 frameDim = DispatchRaysDimensions().xy;

    //TODO this does not seem completly right (depth too small or too big)
    float2 relFramePosCorners[4];
    relFramePosCorners[0] = (pixel + float2(-kPixelOffset, -kPixelOffset)) / frameDim;
    relFramePosCorners[1] = (pixel + float2(kPixelOffset, -kPixelOffset)) / frameDim;
    relFramePosCorners[2] = (pixel + float2(-kPixelOffset, kPixelOffset)) / frameDim;
    relFramePosCorners[3] = (pixel + float2(kPixelOffset, kPixelOffset)) / frameDim;
    //From [0,1] to [-1,1]
    for (uint i = 0; i < 4; i++) {
        relFramePosCorners[i] = relFramePosCorners[i] * 2.0 - 1.0;
        relFramePosCorners[i].y *= -1.f;
    }
    float3 corners[4];
    posH.z /= posH.w; // Get depth
    //To view space
    for (uint i = 0; i < 4; i++) {
        float4 corner = mul(gInvProj, float4(relFramePosCorners[i], posH.z, 1.0));
        corners[i] = corner.xyz / corner.w;
    }
    // View normal
    float3 faceN = sd.frontFacing ? sd.faceN : -sd.faceN;
    float3 normalView = normalize(mul(gView, float4(faceN, 0)).xyz);
    // Plane equation d
    float d = -1.0 * dot(posView, normalView);
    float maxDepth = rayData.depth;
    float minDepth = rayData.depth;

    for (uint i = 0; i < 4; i++) {
        float cornerDepth = (-d - (normalView.x * corners[i].x) - (normalView.y * corners[i].y)) / (normalView.z + 1e-10); //Negative due to view space
        maxDepth = max(abs(cornerDepth), maxDepth);
        minDepth = min(abs(cornerDepth), minDepth);
    }

    rayData.depthRange = max(max(maxDepth - rayData.depth , rayData.depth - minDepth),1e-8); //TODO test
    
    rayData.dist = RayTCurrent();
}

//
// Shader entry point for ray generation shader.
//
[shader("raygeneration")]
void rayGen()
{
    uint2 pixel = DispatchRaysIndex().xy;
    uint2 frameDim = DispatchRaysDimensions().xy;
    
    float2 pixelSample = pixel + 0.5; //+ kMSAAPattern[gFrameCount % 16];

    float2 relFramePos = pixelSample / frameDim;
    relFramePos = relFramePos * 2.0 - 1.0; // From [0,1] to [-1,1]
    relFramePos.y *= -1.f;

    float4 posWPixelNear = mul(gInvViewProj, float4(relFramePos, 0.f, 1.f));
    float4 posWPixelFar = mul(gInvViewProj, float4(relFramePos, 1.f, 1.f));

    posWPixelNear.xyz /= posWPixelNear.w;
    float3 toNear = posWPixelNear.xyz - gLightPos;

    RayDesc ray;
    ray.TMin = length(toNear); ;                                                                  // Always start at depth 0
    ray.TMax = distance(gLightPos, posWPixelFar.xyz / posWPixelFar.w); // Real far for the pixel
    ray.Origin = gLightPos;
    ray.Direction = normalize(toNear); // World direction

    RayData rayData = RayData();
    bool useRayTracing = true;
    float lastMinDepth = 0.0;
    float lastDepthRange = 0.0;
    float2 lastTransmittances = float2(1.0);
    // Loop to get all possible samples
    for (uint i = 0; (i < MAX_ELEMENTS) && useRayTracing ; i++) {
        rayData.depth = -1;
        rayData.dist = -1;

        //Trace ray
        uint rayFlags = 0;
        TraceRay(gScene.rtAccel, rayFlags, 0xff /* kShadowRayInstanceMask instanceInclusionMask */, 0 /* hitIdx */, rayTypeCount, 0 /* missIdx */, ray, rayData);

    #if ACCEL_MODE  == ACCEL_MODE_SHADOW3D

        // A miss or opaque object ends the ray
        if (i == 0 && rayData.dist < 0)
            return;

        //End ray tracing for the next frame
        if (rayData.currentTransmittance <= kMinOpacity || rayData.dist < 0) {
            useRayTracing = false;
        }

        if (rayData.dist > 0 && i > 0) {
            // Write output
            float3 minPoint = float3(pixelSample.x - kPixelOffset, pixelSample.y - kPixelOffset, lastMinDepth);
            float3 maxPoint = float3(pixelSample.x + kPixelOffset, pixelSample.y + kPixelOffset, rayData.depth);

            uint insertIdx = 0;
            InterlockedAdd(gCounter[0], 1u, insertIdx);
            if (insertIdx > MAX_IDX)
                return;

            gAABB[insertIdx] = AABB(minPoint, maxPoint);
            gData[insertIdx] = float4(lastTransmittances.y, lastTransmittances.x,0,0); // Transmittance last sample

        }
        // Update for next iteration
        if (rayData.dist > 0) {
            ray.TMin = rayData.dist;
            lastMinDepth = rayData.depth;
            lastTransmittances.y = lastTransmittances.x;
            lastTransmittances.x = rayData.currentTransmittance;
        }

    #else // ACCEL_MODE == ACCEL_MODE_NORMALOFFSET

        // A miss or opaque object ends the ray
        if (i == 0 && rayData.dist < 0)
            return;

        //End ray tracing for the next frame
        if (rayData.currentTransmittance <= kMinOpacity || rayData.dist < 0) {
            useRayTracing = false;
        }

        if (rayData.dist > 0 && i>0) {
            // Write output
            float3 minPoint = float3(pixelSample.x - kPixelOffset, pixelSample.y - kPixelOffset, lastMinDepth - lastDepthRange);
            float3 maxPoint = float3(pixelSample.x + kPixelOffset, pixelSample.y + kPixelOffset, max(lastMinDepth + lastDepthRange, rayData.depth - rayData.depthRange));

            uint insertIdx = 0;
            InterlockedAdd(gCounter[0], 1u, insertIdx);
            if (insertIdx > MAX_IDX)
                return;

            gAABB[insertIdx] = AABB(minPoint, maxPoint);
            gData[insertIdx] = float4(lastDepthRange * 2, lastTransmittances.y, lastTransmittances.x, 0); // Transmittance last sample

        }
        // Update for next iteration
        if (rayData.dist > 0) {
            ray.TMin = rayData.dist;
            lastMinDepth = rayData.depth;
            lastDepthRange = rayData.depthRange;
            lastTransmittances.y = lastTransmittances.x;
            lastTransmittances.x = rayData.currentTransmittance;
        }
    #endif
    }

// Insert last element
#if ACCEL_MODE == ACCEL_MODE_SHADOW3D
    if (lastMinDepth < gFar && (lastTransmittances.x < 1.0)) {
        float3 minPoint = float3(pixelSample.x - kPixelOffset, pixelSample.y - kPixelOffset, lastMinDepth);
        float3 maxPoint = float3(pixelSample.x + kPixelOffset, pixelSample.y + kPixelOffset, gFar);

        uint insertIdx = 0;
        InterlockedAdd(gCounter[0], 1u, insertIdx);
        if (insertIdx > MAX_IDX)
            return;

        gAABB[insertIdx] = AABB(minPoint, maxPoint);
        gData[insertIdx] = float4(lastTransmittances.x, lastTransmittances.x,0,0); // Transmittance last sample
    }
#else // ACCEL_MODE == ACCEL_MODE_NORMALOFFSET
    if (lastMinDepth < gFar && (lastTransmittances.x < 1.0)) {
        float3 minPoint = float3(pixelSample.x - kPixelOffset, pixelSample.y - kPixelOffset, lastMinDepth - lastDepthRange);
        float3 maxPoint = float3(pixelSample.x + kPixelOffset, pixelSample.y + kPixelOffset, max(lastMinDepth + lastDepthRange, gFar));

        uint insertIdx = 0;
        InterlockedAdd(gCounter[0], 1u, insertIdx);
        if (insertIdx > MAX_IDX)
            return;

        gAABB[insertIdx] = AABB(minPoint, maxPoint);
        gData[insertIdx] = float4(lastDepthRange * 2, lastTransmittances.y, lastTransmittances.x, 0); // Transmittance last sample
    }
#endif
}
